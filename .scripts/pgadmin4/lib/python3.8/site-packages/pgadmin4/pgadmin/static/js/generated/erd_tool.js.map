{"version":3,"file":"erd_tool.js","mappings":";;;AAsFA","sources":["webpack:///./pgadmin/tools/erd/static/js/erd_tool/links/OneToManyLink.jsx"],"sourcesContent":["/////////////////////////////////////////////////////////////\n//\n// pgAdmin 4 - PostgreSQL Tools\n//\n// Copyright (C) 2013 - 2024, The pgAdmin Development Team\n// This software is released under the PostgreSQL Licence\n//\n//////////////////////////////////////////////////////////////\n\nimport React, { forwardRef, useContext } from 'react';\nimport {\n  RightAngleLinkModel,\n  RightAngleLinkWidget,\n  DefaultLinkFactory,\n  PortModelAlignment,\n  LinkWidget,\n  PointModel,\n} from '@projectstorm/react-diagrams';\nimport {Point} from '@projectstorm/geometry';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport { styled } from '@mui/material/styles';\nimport { ERDCanvasSettings } from '../components/ERDTool';\nimport { keyframes } from '@emotion/react';\n\nexport const POINTER_SIZE = 30;\n\nexport const OneToManyModel = {\n  local_table_uid: undefined,\n  local_column_attnum: undefined,\n  referenced_table_uid: undefined,\n  referenced_column_attnum: undefined,\n};\n\nexport class OneToManyLinkModel extends RightAngleLinkModel {\n  constructor({data, ...options}) {\n    super({\n      type: 'onetomany',\n      width: 1,\n      class: 'link-onetomany',\n      locked: true,\n      ...options,\n    });\n\n    this._data = {\n      ...data,\n    };\n  }\n\n  getData() {\n    return this._data;\n  }\n\n  setData(data) {\n    this._data = data;\n  }\n\n  serializeData(nodesDict) {\n    let data = this.getData();\n    let target = nodesDict[data['local_table_uid']].getData();\n    let source = nodesDict[data['referenced_table_uid']].getData();\n    return {\n      'schema': target.schema,\n      'table': target.name,\n      'remote_schema': source.schema,\n      'remote_table': source.name,\n      'columns': [{\n        'local_column': _.find(target.columns, (col)=>data.local_column_attnum == col.attnum).name,\n        'referenced': _.find(source.columns, (col)=>data.referenced_column_attnum == col.attnum).name,\n      }],\n    };\n  }\n\n  serialize() {\n    return {\n      ...super.serialize(),\n      data: this.getData(),\n    };\n  }\n}\n\nconst svgLinkSelected =   keyframes`\n  from { stroke-dashoffset: 24;}\n  to { stroke-dashoffset: 0; }\n`;\n\nconst StyledG = styled('g')((\n  {\n    theme\n  }\n) => ({\n\n  '& .OneToMany-svgLink': {\n    stroke: theme.palette.text.primary,\n    fontSize: '0.8em',\n  },\n  '& .OneToMany-svgLinkCircle': {\n    fill: theme.palette.text.primary,\n  },\n\n  '& .OneToMany-svgLinkSelected': {\n    strokeDasharray: '10, 2',\n    animation: `${svgLinkSelected} 1s linear infinite`\n  },\n  '& .OneToMany-svgLinkPath': {\n    pointerEvents: 'all',\n    cursor: 'move',\n  }\n}));\n\n\nfunction ChenNotation({rotation, type}) {\n\n  const textX = Math.sign(rotation) > 0 ? -14 : 8;\n  const textY = -5;\n  return (\n    <>\n      <text className='OneToMany-svgLink' x={textX} y={textY} transform={'rotate(' + -rotation + ')' }>\n        {type == 'one' ? '1' : 'N'}\n      </text>\n      <line className='OneToMany-svgLink' x1=\"0\" y1=\"0\" x2=\"0\" y2=\"30\"></line>\n    </>\n  );\n}\nChenNotation.propTypes = {\n  rotation: PropTypes.number,\n  type: PropTypes.string,\n};\n\nfunction CustomLinkEndWidget(props) {\n  const { point, rotation, tx, ty, type } = props;\n\n  const settings = useContext(ERDCanvasSettings);\n\n  const svgForType = (itype) => {\n    if(settings.cardinality_notation == 'chen') {\n      return <ChenNotation rotation={rotation} type={itype} />;\n    }\n    if(itype == 'many') {\n      return (\n        <>\n          <circle className={['OneToMany-svgLink','OneToMany-svgLinkCircle'].join(' ')} cx=\"0\" cy=\"16\" r={props.width*2.5} strokeWidth={props.width} />\n          <polyline className='OneToMany-svgLink' points=\"-8,0 0,15 0,0 0,30 0,15 8,0\" fill=\"none\" strokeWidth={props.width} />\n        </>\n      );\n    } else if (itype == 'one') {\n      return (\n        <polyline className='OneToMany-svgLink' points=\"-8,15 0,15 0,0 0,30 0,15 8,15\" fill=\"none\" strokeWidth={props.width} />\n      );\n    }\n  };\n\n  return (\n    <g transform={'translate(' + point.getPosition().x + ', ' + point.getPosition().y + ')'}>\n      <g transform={'translate('+tx+','+ty+')'}>\n        <g transform={'rotate(' + rotation + ')' }>\n          {svgForType(type)}\n        </g>\n      </g>\n    </g>\n  );\n}\n\nCustomLinkEndWidget.propTypes = {\n  point: PropTypes.instanceOf(PointModel).isRequired,\n  rotation: PropTypes.number.isRequired,\n  tx: PropTypes.number.isRequired,\n  ty: PropTypes.number.isRequired,\n  type: PropTypes.oneOf(['many', 'one']).isRequired,\n  width: PropTypes.number,\n};\n\nexport class OneToManyLinkWidget extends RightAngleLinkWidget {\n  constructor(props) {\n    super(props);\n  }\n\n  endPointTranslation(alignment) {\n    let degree = 0;\n    let tx = 0, ty = 0;\n    switch(alignment) {\n    case PortModelAlignment.BOTTOM:\n      ty = -POINTER_SIZE;\n      break;\n    case PortModelAlignment.LEFT:\n      degree = 90;\n      tx = POINTER_SIZE;\n      break;\n    case PortModelAlignment.TOP:\n      degree = 180;\n      ty = POINTER_SIZE;\n      break;\n    case PortModelAlignment.RIGHT:\n      degree = -90;\n      tx = -POINTER_SIZE;\n      break;\n    }\n    return [degree, tx, ty];\n  }\n\n  addCustomWidgetPoint(type, endpoint, point) {\n    const [rotation, tx, ty] = this.endPointTranslation(endpoint.options.alignment);\n    if(!point) {\n      point = this.props.link.point(\n        endpoint.getX()-tx, endpoint.getY()-ty, {'one': 1, 'many': 2}[type]\n      );\n    } else {\n      point.setPosition(endpoint.getX()-tx, endpoint.getY()-ty);\n    }\n\n    return {\n      type: type,\n      point: point,\n      rotation: rotation,\n      tx: tx,\n      ty: ty,\n    };\n  }\n\n  generateCustomEndWidget({type, point, rotation, tx, ty}) {\n    return (\n      <CustomLinkEndWidget\n        key={point.getID()}\n        point={point}\n        rotation={rotation}\n        tx={tx}\n        ty={ty}\n        type={type}\n        colorSelected={this.props.link.getOptions().selectedColor}\n        color={this.props.link.getOptions().color}\n        width={this.props.width}\n      />\n    );\n  }\n\n  draggingEvent(event, index) {\n    let points = this.props.link.getPoints();\n    // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n    // moving with y direction\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  handleMove = function(event) {\n    this.props.link.getTargetPort();\n    this.draggingEvent(event, this.dragging_index);\n    this.props.link.fireEvent({}, 'positionChanged');\n  }.bind(this);\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = [];\n\n    let onePoint = this.addCustomWidgetPoint('one', this.props.link.getSourcePort(), points[0]);\n    let manyPoint = this.addCustomWidgetPoint('many', this.props.link.getTargetPort(), points[points.length-1]);\n\n    if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else if (this.props.link.getLastPathXdirection()) {\n          points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n        } else {\n          points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n        }\n      }\n    }\n\n    // If there is existing link which has two points add one\n    if (points.length === 2 && !this.state.canDrag && onePoint.point.getX() != manyPoint.point.getX()) {\n      this.props.link.addPoint(\n        new PointModel({\n          link: this.props.link,\n          position: new Point(onePoint.point.getX(), manyPoint.point.getY()),\n        })\n      );\n    }\n\n    paths.push(this.generateCustomEndWidget(onePoint));\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(\n        this.generateLink(\n          LinkWidget.generateLinePath(points[j], points[j + 1]),\n          {\n            'data-linkid': this.props.link.getID(),\n            'data-point': j,\n            onMouseDown: (event) => {\n              if (event.button === 0) {\n                this.setState({ canDrag: true });\n                this.dragging_index = j;\n                // Register mouse move event to track mouse position\n                // On mouse up these events are unregistered check \"this.handleUp\"\n                window.addEventListener('mousemove', this.handleMove);\n                window.addEventListener('mouseup', this.handleUp);\n              }\n            },\n            onMouseEnter: () => {\n              this.setState({ selected: true });\n              this.props.link.lastHoverIndexOfPath = j;\n            },\n          },\n          j\n        )\n      );\n    }\n    paths.push(this.generateCustomEndWidget(manyPoint));\n\n    this.refPaths = [];\n    return <StyledG data-default-link-test={this.props.link.getOptions().testName}>{paths}</StyledG>;\n  }\n}\n\nconst LinkSegment = forwardRef(({model, selected, path, ...props}, ref)=>{\n\n  return (\n    <path\n      ref={ref}\n      className={['OneToMany-svgLink','OneToMany-svgLinkPath', (selected ? 'OneToMany-svgLinkSelected' : '')].join(' ')}\n      stroke={model.getOptions().color}\n      strokeWidth={model.getOptions().width}\n      selected={selected}\n      d={path}\n      {...props}\n    >\n    </path>\n  );\n});\nLinkSegment.displayName = 'LinkSegment';\nLinkSegment.propTypes = {\n  model: PropTypes.object,\n  selected: PropTypes.bool,\n  path: PropTypes.any,\n};\n\n\nexport class OneToManyLinkFactory extends DefaultLinkFactory {\n  constructor() {\n    super('onetomany');\n  }\n\n  generateModel(event) {\n    return new OneToManyLinkModel(event.initialConfig);\n  }\n\n  generateReactWidget(event) {\n    return <OneToManyLinkWidget width={1} smooth={true} link={event.model} diagramEngine={this.engine} factory={this} />;\n  }\n\n  generateLinkSegment(model, selected, path) {\n    return <LinkSegment model={model} selected={selected} path={path} />;\n  }\n}\n"],"names":[],"sourceRoot":""}